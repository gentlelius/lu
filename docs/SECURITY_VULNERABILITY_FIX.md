# 安全漏洞修复方案

## 问题描述

当前系统存在严重的安全漏洞，允许未配对的 app 直接连接到 runner：

### 漏洞 1：绕过配对机制
**位置**：`app/app/index.tsx`

```typescript
// ⚠️ 硬编码的 runner ID，无需配对
const runnerId = 'runner-1';
socketService.connectToRunner(runnerId, newSessionId);
```

**问题**：
- 使用旧的 `socketService` 直接连接
- 硬编码 `runnerId`，绕过配对流程
- 任何人只要知道 `runnerId` 就可以连接

### 漏洞 2：Broker 未验证配对关系
**位置**：`broker/src/gateway/events.gateway.ts`

```typescript
@SubscribeMessage('connect_runner')
handleConnectRunner(
  @ConnectedSocket() client: Socket,
  @MessageBody() payload: { runnerId: string; sessionId: string },
) {
  const runner = this.runnerService.getRunner(payload.runnerId);
  if (!runner) {
    client.emit('error', { message: 'Runner not found or offline' });
    return;
  }
  // ⚠️ 没有验证 app 是否已与 runner 配对
  this.sessions.set(payload.sessionId, {
    appSocketId: client.id,
    runnerId: payload.runnerId,
  });
  // ...
}
```

**问题**：
- 没有检查 app 是否已与 runner 配对
- 任何已认证的 app 都可以连接任何在线的 runner

## 安全风险

1. **未授权访问**：攻击者可以连接到任何在线的 runner
2. **命令执行**：可以在受害者的机器上执行任意命令
3. **数据泄露**：可以读取 runner 机器上的文件和数据
4. **横向移动**：可以使用 runner 作为跳板攻击其他系统

## 修复方案

### 1. 修改 Broker Gateway - 添加配对验证

**文件**：`broker/src/gateway/events.gateway.ts`

```typescript
import { PairingSessionService } from '../pairing/pairing-session/pairing-session.service';

@WebSocketGateway({...})
export class EventsGateway implements OnGatewayConnection, OnGatewayDisconnect {
  constructor(
    private readonly runnerService: RunnerService,
    private readonly authService: AuthService,
    private readonly pairingSessionService: PairingSessionService, // 添加
  ) {}

  @SubscribeMessage('connect_runner')
  async handleConnectRunner(
    @ConnectedSocket() client: Socket,
    @MessageBody() payload: { runnerId: string; sessionId: string },
  ) {
    // 1. 获取 app 的 userId
    const userId = this.socketToUser.get(client.id);
    if (!userId) {
      client.emit('error', { message: 'Not authenticated' });
      return;
    }

    // 2. 验证配对关系
    const isPaired = await this.pairingSessionService.isPaired(userId, payload.runnerId);
    if (!isPaired) {
      client.emit('error', { 
        message: 'Not paired with this runner. Please pair first.',
        code: 'NOT_PAIRED'
      });
      return;
    }

    // 3. 检查 runner 是否在线
    const runner = this.runnerService.getRunner(payload.runnerId);
    if (!runner) {
      client.emit('error', { message: 'Runner not found or offline' });
      return;
    }

    // 4. 创建会话
    this.sessions.set(payload.sessionId, {
      appSocketId: client.id,
      runnerId: payload.runnerId,
    });

    runner.socket.emit('create_session', { sessionId: payload.sessionId });
    client.emit('session_created', { sessionId: payload.sessionId });
  }
}
```

### 2. 修改 App - 使用 AppClient 和配对流程

**文件**：`app/app/index.tsx`

需要完全重写，使用 `AppClient` 替代 `socketService`：

```typescript
import { AppClient } from '../src/services/app-client';

export default function TerminalScreen() {
  const router = useRouter();
  const appClient = useRef<AppClient>(new AppClient()).current;
  
  // 状态管理
  const [pairingState, setPairingState] = useState<PairingState | null>(null);
  const [connectionState, setConnectionState] = useState<ConnectionState>('disconnected');
  
  useEffect(() => {
    // 连接到 broker
    connectToBroker();
    
    // 监听配对状态
    appClient.on('pairing:status', handlePairingStatus);
    appClient.on('runner:offline', handleRunnerOffline);
    
    return () => {
      appClient.off('pairing:status', handlePairingStatus);
      appClient.off('runner:offline', handleRunnerOffline);
      appClient.disconnect();
    };
  }, []);
  
  const connectToBroker = async () => {
    setConnectionState('connecting');
    try {
      await appClient.connect({
        brokerUrl: 'http://localhost:3000',
        jwtToken: 'demo-token',
      });
      
      // 检查配对状态
      const status = await appClient.getPairingStatus();
      setPairingState(status);
      
      if (status.isPaired && status.runnerOnline) {
        setConnectionState('paired');
      } else if (status.isPaired && !status.runnerOnline) {
        setConnectionState('runner_offline');
      } else {
        setConnectionState('not_paired');
      }
    } catch (err) {
      setConnectionState('error');
    }
  };
  
  // 只有配对后才能连接
  const handleStartSession = useCallback(() => {
    if (!pairingState?.isPaired || !pairingState.runnerId) {
      setError('Please pair with a runner first');
      router.push('/pairing');
      return;
    }
    
    // 使用配对的 runnerId
    const newSessionId = `session-${Date.now()}`;
    socketService.connectToRunner(pairingState.runnerId, newSessionId);
  }, [pairingState]);
  
  // UI 根据配对状态显示
  if (connectionState === 'not_paired') {
    return (
      <View style={styles.centerContent}>
        <Text style={styles.infoText}>Not paired with any runner</Text>
        <TouchableOpacity 
          style={styles.button} 
          onPress={() => router.push('/pairing')}
        >
          <Text style={styles.buttonText}>Go to Pairing</Text>
        </TouchableOpacity>
      </View>
    );
  }
  
  // ... 其他 UI
}
```

### 3. 添加 PairingSessionService 方法

**文件**：`broker/src/pairing/pairing-session/pairing-session.service.ts`

```typescript
/**
 * Check if an app is paired with a runner
 * 
 * @param appId - App user ID
 * @param runnerId - Runner ID
 * @returns true if paired, false otherwise
 */
async isPaired(appId: string, runnerId: string): Promise<boolean> {
  const key = `pairing:session:app:${appId}`;
  const storedRunnerId = await this.redisService.get(key);
  return storedRunnerId === runnerId;
}
```

### 4. 废弃旧的 socketService

**文件**：`app/src/services/socket.ts`

添加警告或完全移除，强制使用 `AppClient`：

```typescript
/**
 * @deprecated Use AppClient instead. This service bypasses pairing security.
 * 
 * SECURITY WARNING: This service allows direct connection to runners without
 * pairing verification. It should not be used in production.
 */
class SocketService {
  // ...
}
```

## 实施步骤

1. **Phase 1 - Broker 修复**（高优先级）
   - [ ] 在 `events.gateway.ts` 中添加配对验证
   - [ ] 在 `PairingSessionService` 中添加 `isPaired()` 方法
   - [ ] 编写单元测试验证配对检查
   - [ ] 部署到生产环境

2. **Phase 2 - App 修复**（高优先级）
   - [ ] 重写 `index.tsx` 使用 `AppClient`
   - [ ] 移除硬编码的 `runnerId`
   - [ ] 添加配对状态检查
   - [ ] 强制用户先配对再连接

3. **Phase 3 - 清理**（中优先级）
   - [ ] 废弃或移除 `socketService`
   - [ ] 更新文档说明配对流程
   - [ ] 添加安全测试用例

## 测试验证

### 测试用例 1：未配对的 app 无法连接
```typescript
it('should reject connection from unpaired app', async () => {
  const app = new AppClient();
  await app.connect({ brokerUrl, jwtToken });
  
  // 尝试直接连接（未配对）
  await expect(
    socketService.connectToRunner('runner-1', 'session-1')
  ).rejects.toThrow('Not paired with this runner');
});
```

### 测试用例 2：配对后可以连接
```typescript
it('should allow connection from paired app', async () => {
  const app = new AppClient();
  await app.connect({ brokerUrl, jwtToken });
  
  // 先配对
  await app.pair('ABC-DEF-GHI');
  
  // 然后连接
  await expect(
    socketService.connectToRunner('runner-1', 'session-1')
  ).resolves.not.toThrow();
});
```

### 测试用例 3：配对过期后无法连接
```typescript
it('should reject connection after pairing expires', async () => {
  const app = new AppClient();
  await app.connect({ brokerUrl, jwtToken });
  await app.pair('ABC-DEF-GHI');
  
  // 等待配对过期
  await sleep(PAIRING_EXPIRY_TIME + 1000);
  
  // 尝试连接
  await expect(
    socketService.connectToRunner('runner-1', 'session-1')
  ).rejects.toThrow('Pairing expired');
});
```

## 影响评估

### 安全影响
- **修复前**：任何人都可以连接任何 runner（严重漏洞）
- **修复后**：只有配对的 app 可以连接对应的 runner（安全）

### 用户体验影响
- **修复前**：可以直接连接（但不安全）
- **修复后**：必须先配对才能连接（增加一步，但更安全）

### 兼容性影响
- **破坏性变更**：是
- **需要更新**：所有 app 客户端
- **向后兼容**：否

## 建议

1. **立即修复 Broker**：这是最关键的，可以立即阻止未授权访问
2. **尽快更新 App**：强制用户更新到安全版本
3. **添加监控**：记录所有连接尝试，检测可疑活动
4. **安全审计**：全面审查其他可能的安全漏洞
5. **文档更新**：明确说明配对是必需的安全步骤

## 参考

- 配对系统设计：`.kiro/specs/runner-app-pairing/design.md`
- 配对会话服务：`broker/src/pairing/pairing-session/`
- App 客户端：`app/src/services/app-client.ts`
